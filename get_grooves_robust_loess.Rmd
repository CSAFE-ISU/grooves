---
title: "get_grooves_robust_loess"
author: "Kiegan Rice"
date: "5/7/2018"
output: pdf_document
---

## Hamby44

**Note: This is the same intro as the "get_grooves_quadratic_explo.R" file - we are making the same adjustments.**  


We will first take a look at the Hamby 44 Rescan data. There are lists of groove predictions (using Eric's smoothing method "rollapply") and groove manual identifications (done by Dr. Hofmann).

`cccata`, within the Hamby 44 Rescan data, contains x-y-value formatted data. 


```{r packages-and-data, echo = F, message = F, warning = F}
library(devtools)
#install.packages("tidyverse")
#library(tidyverse)
library(tidyr)
library(dplyr)
library(purrr)
library(ggplot2)

#devtools::install_github("CSAFE-ISU/bulletr")
#library(bulletr)


#hamby44 <- readRDS("/home/ricek/hamby44.rda")
hamby44 <- readRDS("//opt/hamby44/hamby44.rda")
#hamby44
hamby44[1:6,]
```

There are a few changes we want to make to the `hamby44` data before we fit things.  

The first is that there are a few lands that are `NA` values, so we just need to filter those out before we can do anything else. It looks like it only happens in two cases, so we are still left with 208 viable lands.    

```{r rm-empty-lands, message = F, warning = F}
hamby44 <- hamby44 %>% filter(!is.na(crosscuts))
```


The second is that since `hamby44` has 10 crosscuts for each land, we will collapse those into one by averaging them. Then hamby44 will have an extra column, ccdata_avg, which is a data frame for each land consisting of the columns `y` and `value`, but here `value` is the averaged values. We will also create a `value_std` which is the averaged value standardized down to 0 if the lowest value is not 0. This can be seen below; the 10 crosscuts are plotted as points, in black. The averaged values are plotted as a red line, and the standardized average values are plotted as a green line. While this is just done for the first land in the data set, and there is not much of a difference here, for some it will be a more pronounced difference.  




```{r avg-and-std-values, echo = F, message = F, warning = F}

hamby44 <- hamby44 %>% mutate(ccdata_avg = purrr::map(ccdata, .f = function(dframe){
  dframe <- dframe %>% group_by(y) %>% summarise(value = mean(value, na.rm = T))
  dframe <- as.data.frame(dframe)
  check_min <- min(dframe$value[!is.na(dframe$value)])
  dframe <- dframe %>% mutate(value_std = value - check_min)
  return(dframe)
}))

#hamby44

ggplot() + geom_point(data = hamby44$ccdata[[1]], aes(x = y, y = value)) + 
  geom_line(data = hamby44$ccdata_avg[[1]], aes(x = y, y = value), color = "red") + 
  geom_line(data = hamby44$ccdata_avg[[1]], aes(x = y, y = value_std), colour = "green") + 
  theme_bw()
```


**Here is where things start to change...**  

We are interested in looking at the residuals from a robust LOESS fit (this changes from the robust linear model fit we previously were considering). There are many instances of a bad linear fit due to a truly non-quadratic bullet land shape with robust linear models, so we want to consider robust LOESS, which appears to do a much better job of both addressing outlier values in the edges and capturing the shape of the bullet land. Thus, we will fit this model and calculate the residuals that occur in order to later use them in assessment. So here, we will calculate the residuals from the robust linear model (`absresid`, `resid`) AND the robust LOESS model (`rlo_absresid`, `rlo_resid`).  

Note that we will do all of this with the `value_std` column from `ccdata_avg`, so we will need to make sure we use `value_std` when we actually run the function later. It calls `value` as it is defined. *Maybe add a parameter to the function that lets you define what the value column is called.*  


```{r calculate-residuals-rlm-rloess, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(ccdata_w_resid = purrr::map(ccdata_avg, .f = function(bullet){
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  bullet$absresid <- with(bullet, abs(value_std-pred))
  bullet$resid <- with(bullet, value_std-pred)
  
  
  robust_loess_fit <- locfit.robust(value_std~y, data = bullet, weights = rep(1, length(value_std)))
  bullet$rlo_pred <- predict(robust_loess_fit, newdata = bullet)
  
  bullet$rlo_absresid <- with(bullet, abs(value_std-rlo_pred))
  bullet$rlo_resid <- with(bullet, value_std-rlo_pred)
  return(bullet)
}))
```


Now that we have all the values we are interested in comparing to calculated, we can define several different functions we had previously considered using for groove identification.  


### get_grooves_rollapply  

here we aren't going to actually define/run the function, there are just "grooves_pred" in the hamby44 datafile.  

```{r calculate-sum_resid_rolls, echo = F, warning = F, message = F}
sum_resid_right_roll <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_pred[[which_bullet]]$groove[2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

sum_rresid_right_roll <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_pred[[which_bullet]]$groove[2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$rdiff_resid_roll <- 0
hamby44$rdiff_rresid_roll <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_roll[i] <- sum_resid_right_roll(datafile = hamby44, which_bullet = i)
  hamby44$rdiff_rresid_roll[i] <- sum_rresid_right_roll(datafile = hamby44, which_bullet = i)
}


sum_resid_left_roll <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_pred[[which_bullet]]$groove[1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}
sum_rresid_left_roll <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_pred[[which_bullet]]$groove[1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$ldiff_resid_sum_roll <- 0
hamby44$ldiff_rresid_sum_roll <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_roll[i] <- sum_resid_left_roll(datafile = hamby44, which_bullet = i)
  hamby44$ldiff_rresid_sum_roll[i] <- sum_rresid_left_roll(datafile = hamby44, which_bullet = i)
}

```

### get_grooves_quadratic  

```{r define-get_grooves_quadratic, message = F, warning = F}
get_grooves_quadratic <- function(bullet, adjust) {
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  bullet$absresid <- with(bullet, abs(value_std-pred))
  bullet$absresid90 <- with(
    bullet, absresid>4*median(bullet$absresid, na.rm=TRUE))

  groove <- range(filter(bullet, !absresid90)$y) + c(adjust, -adjust)
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  
  return(list(groove = groove, plot = plot))
}

```

```{r run-get_grooves_quadratic, message = F, warning = F}

hamby44 <- hamby44 %>% mutate(grooves_quad_pred = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_quadratic(bullet = x, adjust = 0)$groove
}))

```


```{r calculate-sum_resid_quads, message = F, warning = F, echo = F}

sum_resid_right <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_quad_pred[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

sum_rresid_right <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_quad_pred[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$rdiff_resid_sum <- 0
hamby44$rdiff_rresid_sum <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum[i] <- sum_resid_right(datafile = hamby44, which_bullet = i)
  hamby44$rdiff_rresid_sum[i] <- sum_rresid_right(datafile = hamby44, which_bullet = i)
}


sum_resid_left <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_quad_pred[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}
sum_rresid_left <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_quad_pred[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$ldiff_resid_sum <- 0
hamby44$ldiff_rresid_sum <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum[i] <- sum_resid_left(datafile = hamby44, which_bullet = i)
  hamby44$ldiff_rresid_sum[i] <- sum_rresid_left(datafile = hamby44, which_bullet = i)
}
```

### get_grooves_quadratic_pos_resid  

```{r define-get_grooves_quadratic_pos_resid, message = F, warning = F}
get_grooves_quadratic_pos_resid <- function(bullet, adjust) {
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  #bullet$absresid <- with(bullet, abs(value-pred))
  bullet$resid <- with(bullet, value_std-pred)
  #bullet$absresid_div <- with(bullet, absresid/value)
  bullet$resid_div <- with(bullet, resid/value_std)
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid)) + theme_bw()
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid_div)) + theme_bw()
  
  bullet$resid_cutoff <- with (bullet, resid_div > 0)
  groove <- range(filter(bullet, !resid_cutoff)$y) + c(adjust, -adjust)
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  
  return(list(groove = groove, plot = plot))
}
```


```{r run-get_grooves_quadratic_pos_resid, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(grooves_quad_pred_pos = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_quadratic_pos_resid(bullet = x, adjust = 0)$groove
}))
```

```{r calculate-sum_resid_quads_pos, echo = F, warning = F, message = F}

sum_resid_right_pos <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_quad_pred_pos[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}
sum_rresid_right_pos <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_quad_pred_pos[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$rdiff_resid_sum_pos <- 0
hamby44$rdiff_rresid_sum_pos <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_pos[i] <- sum_resid_right_pos(datafile = hamby44, which_bullet = i)
  hamby44$rdiff_rresid_sum_pos[i] <- sum_rresid_right_pos(datafile = hamby44, which_bullet = i)
}


sum_resid_left_pos <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_quad_pred_pos[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}
sum_rresid_left_pos <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_quad_pred_pos[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$ldiff_resid_sum_pos <- 0
hamby44$ldiff_rresid_sum_pos <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_pos[i] <- sum_resid_left_pos(datafile = hamby44, which_bullet = i)
  hamby44$ldiff_rresid_sum_pos[i] <- sum_resid_left_pos(datafile = hamby44, which_bullet = i)
}

```


### get_grooves_mad  

```{r define_get-grooves-mad, echo = F, message = F, warning = F}
get_grooves_mad <- function(bullet, adjust, multiplier){
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  bullet$absresid <- with(bullet, abs(value_std-pred))
  #bullet$resid <- with(bullet, value_std-pred)
  bullet$absresid_div <- with(bullet, absresid/value_std)
  #bullet$resid_div <- with(bullet, resid/value_std)
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid)) + theme_bw()
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid_div)) + theme_bw()
  mad1 <- mad(bullet$absresid, na.rm = T)
  bullet$resid_cutoff <- with(bullet, absresid > mad1*multiplier)
  groove <- range(filter(bullet, !resid_cutoff)$y) + c(adjust, -adjust)
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  
  return(list(groove = groove, plot = plot))
}

```

```{r calculate_get-grooves-mad1, echo = F, message = F, warning = F}
hamby44 <- hamby44 %>% mutate(grooves_mad1 = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_mad(bullet = x, adjust = 0, multiplier = 1)$groove
}))
```

```{r calculate-sum_resid_mads, echo = F, warning = F, message = F}
sum_resid_right_m1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_mad1[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

sum_rresid_right_m1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_mad1[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}


hamby44$rdiff_resid_sum_m1 <- 0
hamby44$rdiff_rresid_sum_m1 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_m1[i] <- sum_resid_right_m1(datafile = hamby44, which_bullet = i)
  hamby44$rdiff_rresid_sum_m1[i] <- sum_rresid_right_m1(datafile = hamby44, which_bullet = i)
}


sum_resid_left_m1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_mad1[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

sum_rresid_left_m1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_mad1[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$ldiff_resid_sum_m1 <- 0
hamby44$ldiff_rresid_sum_m1 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_m1[i] <- sum_resid_left_m1(datafile = hamby44, which_bullet = i)
  hamby44$ldiff_rresid_sum_m1[i] <- sum_rresid_left_m1(datafile = hamby44, which_bullet = i)
}
```


### get_grooves_mad2

```{r calculate_get-grooves-mad2, echo = F, message = F, warning = F}
hamby44 <- hamby44 %>% mutate(grooves_mad2 = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_mad(bullet = x, adjust = 0, multiplier = 2)$groove
}))
```  


### predicting groove sides  

```{r explore-groove-locations, echo = F, warning = F, message = F}

hamby44$left_groove <- 0
hamby44$right_groove <- 0
for(i in 1:nrow(hamby44)){
  hamby44$left_groove[i] <- hamby44$grooves[[i]]$groove[1]
  hamby44$right_groove[i] <- hamby44$grooves[[i]]$groove[2]
}

summary(hamby44$left_groove) # Left grooves, from 15.48 to 543.74
summary(hamby44$right_groove) # Right grooves, from 1872 to 2351

hamby44 %>% ggplot() + geom_histogram(aes(x = left_groove), fill = "salmon")  + 
  geom_histogram(aes(x = right_groove), fill = "turquoise") + 
  labs(x = "Groove Locations") + theme_bw()
```

Now, let's take a look at summing up residuals from 0 to the highest left groove location, and from the lowest right groove location up to the max y value.  

```{r, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(left_resid_sum = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y < 600) 
  sum(bullet$resid, na.rm = T)
}), 
right_resid_sum = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y > 1800)
  sum(bullet$resid, na.rm = T)
}),
left_rlo_resid_sum = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y < 600)
  sum(bullet$rlo_resid, na.rm = T)
}), 
right_rlo_resid_sum = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y > 1800)
  sum(bullet$rlo_resid, na.rm = T)
}))

hamby44 %>% ggplot() + geom_histogram(aes(x = left_resid_sum), fill = "salmon", alpha = 0.3) + geom_histogram(aes(x = right_resid_sum), fill = "turquoise", alpha = 0.3) + theme_bw() 

hamby44 %>% ggplot() + geom_histogram(aes(x = left_rlo_resid_sum), fill = "salmon", alpha = 0.3) + geom_histogram(aes(x = right_rlo_resid_sum), fill = "turquoise", alpha = 0.3) + theme_bw()

## Based on the plot, let's go with a cutoff of residual higher than 1000 means there is a groove there for the right side... but I have no idea for the right side!! Let's see if we can get some sort of ground truth...  



```









### define whether there is or is not a groove  

```{r define-is-groove, echo = F, warning = F, message = F}

hamby44$is_left_groove <- c(1, 1, 1, 1, 1, #5
                            1, 1, 1, 1, 0, #10
                            1, 1, 1, 1, 1, #15
                            1, 1, 1, 1, 1, #20
                            1, 1, 1, 1, 1, #25
                            1, 1, 1, 1, 1, #30
                            1, 0, 1, 1, 1, #35
                            1, 1, 1, 1, 1, #40
                            1, 1, 1, 1, 1, #45
                            1, 1, 1, 1, 1, #50
                            1, 1, 1, 1, 1, #55
                            1, 1, 0, 1, 1, #60
                            1, 1, 1, 1, 1, #65
                            1, 1, 1, 1, 1, #70
                            1, 1, 1, 1, 1, #75
                            1, 1, 1, 1, 1, #80
                            1, 1, 1, 1, 1, #85
                            1, 1, 1, 1, 1, #90
                            1, 1, 1, 1, 1, #95
                            1, 1, 1, 0, 1, #100
                            1, 1, 1, 1, 1, #105
                            1, 1, 1, 1, 1, #110
                            1, 1, 1, 1, 1, #115
                            1, 1, 1, 1, 1, #120
                            1, 1, 1, 1, 1, #125
                            1, 1, 1, 1, 1, #130
                            1, 1, 1, 1, 1, #135
                            1, 1, 1, 1, 1, #140
                            1, 1, 1, 1, 1, #145
                            1, 1, 1, 1, 1, #150
                            1, 1, 1, 1, 1, #155
                            1, 1, 1, 1, 1, #160
                            1, 1, 1, 1, 1, #165
                            1, 1, 1, 1, 1, #170
                            1, 1, 1, 1, 1, #175
                            1, 1, 1, 1, 1, #180
                            1, 1, 1, 1, 1, #185
                            1, 1, 1, 1, 1, #190
                            1, 1, 1, 1, 1, #195
                            1, 1, 1, 1, 1, #200
                            1, 1, 1, 1, 1, #205
                            1, 1, 1)

hamby44$is_right_groove <- c(1, 1, 0, 0, 0, #5 
                             1, 0, 0, 0, 1, #10
                             0, 0, 1, 1, 0, #15
                             0, 1, 1, 1, 0, #20
                             0, 0, 0, 1, 0, #25
                             1, 0, 0, 0, 0, #30
                             1, 1, 1, 0, 1, #35
                             0, 1, 1, 1, 0, #40
                             0, 0, 0, 1, 0, #45
                             1, 0, 1, 0, 0, #50
                             1, 0, 0, 1, 0, #55
                             0, 0, 1, 1, 0, #60
                             0, 1, 0, 0, 1, #65
                             1, 0, 1, 1, 1, #70
                             0, 0, 1, 0, 1, #75
                             0, 1, 0, 1, 0, #80
                             0, 1, 0, 1, 1, #85
                             1, 0, 1, 0, 1, #90
                             0, 0, 0, 1, 1, #95
                             1, 0, 1, 1, 1, #100
                             0, 0, 1, 1, 0, #105
                             0, 0, 1, 0, 0, #110
                             0, 1, 1, 1, 0, #115
                             0, 1, 0, 1, 0, #120
                             1, 1, 1, 0, 0, #125
                             0, 1, 1, 1, 1, #130
                             1, 1, 0, 1, 1, #135
                             1, 1, 0, 0, 0, #140
                             0, 0, 0, 0, 0, #145
                             0, 1, 1, 0, 0, #150
                             1, 1, 0, 1, 0, #155
                             0, 1, 0, 0, 0, #160
                             0, 0, 0, 0, 1, #165
                             1, 0, 1, 0, 0, #170
                             1, 1, 0, 0, 0, #175
                             0, 0, 1, 0, 1, #180
                             0, 1, 0, 1, 0, #185
                             1, 1, 1, 1, 0, #190
                             1, 1, 1, 0, 1, #195
                             1, 1, 1, 0, 1, #200
                             0, 1, 0, 1, 0, #205
                             1, 0, 1)


```



```{r, echo = F, warning = F, message = F}

hamby44 %>% filter(!is.na(is_left_groove)) %>% ggplot() + geom_histogram(aes(x = left_rlo_resid_sum, fill = factor(is_left_groove))) + theme_bw()

hamby44 %>% filter(!is.na(is_right_groove)) %>% ggplot() + geom_histogram(aes(x = right_rlo_resid_sum, fill = factor(is_right_groove)), binwidth = 200) + theme_bw()


hamby44 %>% ggplot() + geom_point(aes(x = left_rlo_resid_sum, y = left_groove, colour = factor(is_left_groove))) + theme_bw()

hamby44 %>% ggplot() + geom_point(aes(x = right_rlo_resid_sum, y = right_groove, colour = factor(is_right_groove))) + theme_bw()
```



### get_grooves_robust_loess  



```{r explore-lowess, echo = F, warning = F, message = F}


bullet <- hamby44$ccdata_w_resid[[3]]
bullet_filter <- subset(bullet, !is.na(value_std))
loess_fit <- fitted(loess(value_std~y, data = bullet_filter, span = 0.75))

lowess_fit <- lowess(x = bullet_filter$y, y = bullet_filter$value_std, f = 0.25, iter = 3, delta = 0.001*diff(range(bullet_filter$y)))$y
## this is doing some weird things - using the same span as in "loess", it gives a waaay smoothed out version that actually appears to be MORE affected by outliers???

## let's try locfit.robust from the locfit package instead
#install.packages("locfit")
library(locfit)

robust_loess_fit <- locfit.robust(value_std~y, data = bullet, weights = rep(1, length(value_std)))
r_loess_fit <- predict(robust_loess_fit, newdata = bullet)
## this looks like a better "robust" fit, and looks fairly promising at that!  


ggplot() + geom_point(data = bullet_filter, aes(x = y, y = value_std)) + 
  geom_line(aes(x = bullet_filter$y, y = loess_fit), colour = "red") + 
  geom_line(aes(x = bullet_filter$y, y = lowess_fit), colour = "blue") + 
  geom_line(aes(x = bullet$y, y = r_loess_fit), colour = "green") + 
  theme_bw()



```



```{r define-get_grooves_robust_loess, echo = F, warning = F, message = F}
get_grooves_robust_loess <- function(bullet, adjust){
  bullet$loess_fit <- predict(loess(value_std~y, data = bullet, span = 0.75), newdata = bullet)
  bullet$robust_loess_fit <- predict(locfit.robust(value_std~y, data = bullet, weights = rep(1, length(value_std))), newdata = bullet)
  
  left <- bullet %>% filter(y < 600) ## this sums up residuals on the left 1/4 or so of the land
  sumleft <- sum(left$loess_fit - left$robust_loess_fit, na.rm = T)
  right <- bullet %>% filter(y > 1800) ## this sums up residuals on the right 1/4 or so of the land  
  sumright <- sum(right$loess_fit - right$robust_loess_fit, na.rm = T)
  
  
  ## can't find a working "Trim" function for numerics, so I'm going to use a little workaround I found  
  
  ## let's first trim down the left side - we almost always need to trim it down.  
  groove_l <- 0
  while(sumleft > 500){
    bullet <- bullet[(round(0.01 * length(bullet$y))) : (length(bullet$y)),]
    loess_new <- loess(value_std~y, data = bullet, span = 0.75)
    rloess_new <- locfit.robust(value_std~y, data = bullet, weights = rep(1, length(value_std)))
    #lm_new <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
    bullet$pred_new <- predict(loess_new, newdata = bullet)
    bullet$rpred_new <- predict(rloess_new, newdata = bullet)
    bullet$diff_new <- with(bullet, pred_new-rpred_new)
    sumleft <- sum(bullet[(bullet$y < 600),]$diff_new, na.rm = T)
    groove_l <- min(bullet$y)
    #redefine sumleft here
  }
  
  groove_r <- max(bullet$y)
  while(sumright > 500){
    bullet <- bullet[1:(round(0.99*length(bullet$y))),]
    loess_new <- loess(value_std~y, data = bullet, span = 0.75)
    rloess_new <- locfit.robust(value_std~y, data = bullet, weights = rep(1, length(value_std)))
    bullet$pred_new <- predict(loess_new, newdata = bullet)
    bullet$rpred_new <- predict(rloess_new, newdata = bullet)
    #lm_new <- MASS::rlm(value_std~poly(y,2), data = bullet, maxit=100)
    #bullet$pred_new <- predict(lm_new, newdata = bullet)
    bullet$diff_new <- with(bullet, pred_new-rpred_new)
    sumright <- sum(bullet[(bullet$y > 1800),]$diff_new, na.rm = T)
    groove_r <- max(bullet$y)
  }
  
  
  groove <- c(groove_l, groove_r)
  
  
  #plot <- bullet %>% ggplot() + geom_line(aes(x = y, y = value_std), size = .5) + theme_bw() +
  #  geom_vline(xintercept=groove[1], colour = "blue") +
  #  geom_vline(xintercept=groove[2], colour = "blue") 
  return(list(groove = groove))
  #return(list(groove = groove, plot = plot))
}



```

```{r calculate-get_grooves_robust_loess, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(grooves_rl1 = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_robust_loess(bullet = x, adjust = 0)$groove
}))
```


```{r calculate_sum_resids_rl1, echo = F, warning = F, message = F}

sum_resid_right_rl1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_rl1[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

sum_rresid_right_rl1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_rl1[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$rdiff_resid_sum_rl1 <- 0
hamby44$rdiff_rresid_sum_rl1 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_rl1[i] <- sum_resid_right_rl1(datafile = hamby44, which_bullet = i)
  hamby44$rdiff_rresid_sum_rl1[i] <- sum_rresid_right_rl1(datafile = hamby44, which_bullet = i)
}


sum_resid_left_rl1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_rl1[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

sum_rresid_left_rl1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_rl1[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$rlo_resid, na.rm = T))
}

hamby44$ldiff_resid_sum_rl1 <- 0
hamby44$ldiff_rresid_sum_rl1
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_rl1[i] <- sum_resid_left_rl1(datafile = hamby44, which_bullet = i)
  hamby44$ldiff_rresid_sum_rl1[i] <- sum_rresid_left_rl1(datafile = hamby44, which_bullet = i)
}


```




```{r compare-get-grooves-methods, echo = F, warning = F, message = F}

resids_dframe <- data.frame(roll_right_q = abs(hamby44$rdiff_resid_roll), roll_left_q = abs(hamby44$ldiff_resid_sum_roll), 
                            roll_right_rlo = abs(hamby44$rdiff_rresid_roll), roll_left_rlo = abs(hamby44$ldiff_rresid_sum_roll), 
                             quad_right_q = abs(hamby44$rdiff_resid_sum), quad_left_q = abs(hamby44$ldiff_resid_sum), 
                             quad_right_rlo = abs(hamby44$rdiff_rresid_sum), quad_left_rlo = abs(hamby44$ldiff_rresid_sum),
                             pos_right_q = abs(hamby44$rdiff_resid_sum_pos), pos_left_q = abs(hamby44$ldiff_resid_sum_pos),
                             pos_right_rlo = abs(hamby44$rdiff_rresid_sum_pos), pos_left_rlo = abs(hamby44$ldiff_rresid_sum_pos),
                             mad1_right_q = abs(hamby44$rdiff_resid_sum_m1), mad1_left_q = abs(hamby44$ldiff_resid_sum_m1),
                             mad1_right_rlo = abs(hamby44$rdiff_rresid_sum_m1), mad1_left_rlo = abs(hamby44$ldiff_rresid_sum_m1),
                             rl1_right_q = abs(hamby44$rdiff_resid_sum_rl1), rl1_left_q = abs(hamby44$ldiff_resid_sum_rl1),
                             rl1_right_rlo = abs(hamby44$rdiff_rresid_sum_rl1), rl1_left_rlo = abs(hamby44$ldiff_rresid_sum_rl1)
                             )

apply(resids_dframe, MARGIN = 2, mean)
apply(resids_dframe, MARGIN = 2, median)

head(resids_dframe)

#resids_dframe$method <- factor(resids_dframe$method, levels = rev(levels(resids_dframe$method)))
resids_dframe <- resids_dframe %>% gather(method, residuals_sum)

#resids_dframe$method <- factor(resids_dframe$method,
#    levels = c('roll_left', 'quad_left', 'pos_left', 'mad1_left', 'mad2_left', 'roll_right', 'quad_right', 'pos_right', 'mad1_right', 'mad2_right'),ordered = TRUE)

#resids_dframe %>% ggplot() + geom_boxplot(aes(x = method, y = residuals_sum)) + 
#  theme_bw() + labs(x = "Method and Groove", y = "Residuals") + scale_x_discrete(labels = c("Rollapply, Left", "RLM, Left", "Rollapply, Right", "RLM, Right"))

#resids_dframe  %>% select(-quad_right, -quad_left) %>% gather(method, residuals_sum) %>% filter(residuals_sum < 2000) %>% 
#  ggplot() + geom_boxplot(aes(x = factor(method), y = residuals_sum)) + theme_bw()

resids_dframe <- resids_dframe %>% mutate(method = as.character(method), Method = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][1]
})), GrooveSide = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][2]
})), 
ResidType = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][3]
})))


resids_dframe %>% mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(5,3,2,1,4)], 
                                         labels = c("Rollapply", "Quadratic", "Robust Linear Model", 
                                                    "Median Absolute Deviation", "Robust Loess"))) %>% 
  ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + 
  theme_bw() + labs(y = "Sum of Residuals") + facet_wrap(~ResidType)


resids_dframe %>% 
  mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(5,3,2,1,4)], 
                         labels = c("Rollapply", "Quadratic", "Robust Linear Model", "Median Absolute Deviation", "Robust Loess")))  %>%
  filter(residuals_sum < 1000) %>% 
  ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + 
  theme_bw() + labs(y = "Sum of Residuals") + facet_wrap(~ResidType)
```

### Note: will need to re-define "sum_resid_right", "sum_resid_left"... these are how we are summing up the residuals between manual ID's and predicted grooves. This is a really gross way to do it, also... there must be a better way!  




