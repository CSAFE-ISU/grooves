---
title: "Assessing Quadratic for Groove Locations"
output: html_document
---


## Hamby44

We will first take a look at the Hamby 44 Rescan data. There are lists of groove predictions (using Eric's smoothing method "rollapply") and groove manual identifications (done by Dr. Hofmann).

`cccata`, within the Hamby 44 Rescan data, contains x-y-value formatted data. 


```{r packages-and-data, echo = F, message = F, warning = F}
library(devtools)
#install.packages("tidyverse")
#library(tidyverse)
library(tidyr)
library(dplyr)
library(purrr)
library(ggplot2)

devtools::install_github("CSAFE-ISU/bulletr")
library(bulletr)


#hamby44 <- readRDS("/home/ricek/hamby44.rda")
hamby44 <- readRDS("//opt/hamby44/hamby44.rda")
#hamby44
hamby44[1:6,]
```


There are a few changes we want to make to the `hamby44` data before we fit things.  

The first is that there are a few lands that are `NA` values, so we just need to filter those out before we can do anything else. It looks like it only happens in two cases, so we are still left with 208 viable lands.    

```{r rm-empty-lands, message = F, warning = F}
hamby44 <- hamby44 %>% filter(!is.na(crosscuts))
```


The second is that since `hamby44` has 10 crosscuts for each land, we will collapse those into one by averaging them. Then hamby44 will have an extra column, ccdata_avg, which is a data frame for each land consisting of the columns `y` and `value`, but here `value` is the averaged values. We will also create a `value_std` which is the averaged value standardized down to 0 if the lowest value is not 0. This can be seen below; the 10 crosscuts are plotted as points, in black. The averaged values are plotted as a red line, and the standardized average values are plotted as a green line. While this is just done for the first land in the data set, and there is not much of a difference here, for some it will be a more pronounced difference.  




```{r avg-and-std-values, echo = F, message = F, warning = F}

hamby44 <- hamby44 %>% mutate(ccdata_avg = purrr::map(ccdata, .f = function(dframe){
  dframe <- dframe %>% group_by(y) %>% summarise(value = mean(value, na.rm = T))
  dframe <- as.data.frame(dframe)
  check_min <- min(dframe$value[!is.na(dframe$value)])
  dframe <- dframe %>% mutate(value_std = value - check_min)
  return(dframe)
}))

#hamby44

ggplot() + geom_point(data = hamby44$ccdata[[1]], aes(x = y, y = value)) + 
  geom_line(data = hamby44$ccdata_avg[[1]], aes(x = y, y = value), color = "red") + 
  geom_line(data = hamby44$ccdata_avg[[1]], aes(x = y, y = value_std), colour = "green") + 
  theme_bw()
```


Now, because one of the things we want to be able to do is look at the residuals from the robust linear model we will fit in the `get_grooves_quadratic` function, we will fit the robust linear model and compute the residuals, in order to have them for future assessment purposes.  **Note here: If we change what settings we are using on the RLM, we need to RERUN this to make sure we are getting the correct residuals.**

Note that we will do this with the `value_std` column from `ccdata_avg`, so we will need to make sure we use `value_std` when we actually run the function later. It calls `value` as it is defined. *Maybe add a parameter to the function that lets you define what the value column is called.*  


```{r calculate-residuals-rlm, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(ccdata_w_resid = purrr::map(ccdata_avg, .f = function(bullet){
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  bullet$absresid <- with(bullet, abs(value_std-pred))
  bullet$resid <- with(bullet, value_std-pred)
  return(bullet)
}))


```



Now that we have made all the changes we need to our data, we can begin exploring the `get_grooves_quadratic` function as it is in the bulletr package, and defined below (with the exception that value is now value_std):  



```{r define-get_grooves_quadratic, message = F, warning = F}
get_grooves_quadratic <- function(bullet, adjust) {
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  bullet$absresid <- with(bullet, abs(value_std-pred))
  bullet$absresid90 <- with(
    bullet, absresid>4*median(bullet$absresid, na.rm=TRUE))

  groove <- range(filter(bullet, !absresid90)$y) + c(adjust, -adjust)
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  
  return(list(groove = groove, plot = plot))
}

```




We can fit the function, and here for simplicity of organization, our output will be just the actual groove values, rather than the groove and the plot that the function output.  

```{r run-get_grooves_quadratic, message = F, warning = F}

hamby44 <- hamby44 %>% mutate(grooves_quad_pred = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_quadratic(bullet = x, adjust = 0)$groove
}))
  

```

Now that we have fitted the function, we can check to see how far away things are from the manually identified grooves. We will calculate four columns: `rollapply_left_diff`, `rollapply_right_diff`, `quadratic_left_diff`, and `quadratic_right_diff`.  This gives us the differences between the fits using rollapply and the manual ID's, as well as the fits using the quadratic and the manual ID's. Note that we will expect a lot of 0 values in the rollapply ones, as if the rollapply is doing a good job of identifying, the manual identification would have kept it at that spot exactly.   

The addition of these columns can be seen below (for the first few rows):  

```{r calculate-differences, echo = F, warning = F, message = F}
for (i in 1:208){
  hamby44$rollapply_left_diff[i] <- hamby44$grooves[[i]]$groove[1] - hamby44$grooves_pred[[i]]$groove[1]
  hamby44$rollapply_right_diff[i] <- hamby44$grooves[[i]]$groove[2] - hamby44$grooves_pred[[i]]$groove[2]
  hamby44$quadratic_left_diff[i] <- hamby44$grooves[[i]]$groove[1] - hamby44$grooves_quad_pred[[i]][1]
  hamby44$quadratic_right_diff[i] <- hamby44$grooves[[i]]$groove[2] - hamby44$grooves_quad_pred[[i]][2]
}

hamby44[1:6,]
```


We can look at some preliminary comparisons of these two methods to see if the original quadratic is even doing much better than the rollapply.  


```{r plot-compare-rollapply-quadratic, echo = F, message = F, warning = F}
hamby44 %>% ggplot() + geom_point(aes(x = abs(rollapply_left_diff), y = abs(quadratic_left_diff)))  + 
  geom_point(aes(x = abs(rollapply_right_diff), y = abs(quadratic_right_diff)), shape = 2) +
  geom_abline(intercept = 0, slope = 1) + 
  labs(x = "Absolute Difference between \n Rollapply Groove and Manual ID Groove", 
       y = "Absolute Difference between \n Quadratic Groove and Manual ID Groove",
       title = "4*Median Cutoff Method") + 
  theme_bw() + 
  ylim(0, 1100) + 
  xlim(0, 1100) + 
  scale_shape_manual(values = c(1,2), labels = c("Left", "Right"))



#hamby44_quad %>% ggplot() + geom_point(aes(x = abs(rollapply_right_diff), y = abs(quadratic_right_diff))) + theme_bw() + geom_abline(intercept = 0, slope = 1)

#hamby44_quad %>% ggplot() + geom_point(aes(x = abs(rollapply_left_diff), y = abs(quadratic_left_diff))) + theme_bw() + geom_abline(intercept = 0, slope = 1)
```



What we will try next is looking at fitting a quadratic, finding the signs of the lags of the residuals, and looking for where the proportion of negative to positive signs change.  
**Note: This proportion thing did not go well. Looking at the patterns of the residuals, there is not an obvious shift in proportion. It zig-zags around quite a bit, so it looks like this will not be helpful.**   



Now, we will try another method for the cutoff value of the residuals. Instead of cutting off at 4 times the median of the absolute residuals, we will instead divide the residuals by their relative height, and take the range of residuals that are non-positive. That is, we expect both positive and negative residuals on the actual curve of the bullet, so we can remove any points that have that positive residuals and take the range of what remains. (Sidenote: This may require more messing around with the adjust, in case it is cutting off too far out or too far in.)  

This new function, `get_grooves_quadratic_pos_resid` (I need a more succinct name) is defined below:  


```{r define-get_grooves_quadratic_pos_resid, message = F, warning = F}
get_grooves_quadratic_pos_resid <- function(bullet, adjust) {
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  #bullet$absresid <- with(bullet, abs(value-pred))
  bullet$resid <- with(bullet, value_std-pred)
  #bullet$absresid_div <- with(bullet, absresid/value)
  bullet$resid_div <- with(bullet, resid/value_std)
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid)) + theme_bw()
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid_div)) + theme_bw()
  
  bullet$resid_cutoff <- with (bullet, resid_div > 0)
  groove <- range(filter(bullet, !resid_cutoff)$y) + c(adjust, -adjust)
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  
  return(list(groove = groove, plot = plot))
}
```

We will now apply this to the `ccdata_avg` set again to get our predicted grooves with this new method.  

```{r run-get_grooves_quadratic_pos_resid, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(grooves_quad_pred_pos = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_quadratic_pos_resid(bullet = x, adjust = 0)$groove
}))
```


Additionally, we can calculate differences between these and the Manually ID'd grooves, and plot the comparison between this and rollapply.  
```{r calculate-differences-2, echo = F, warning = F, message = F}

for (i in 1:nrow(hamby44)){
  hamby44$quadratic_pos_left_diff[i] <- hamby44$grooves[[i]]$groove[1] - hamby44$grooves_quad_pred_pos[[i]][1]
  hamby44$quadratic_pos_right_diff[i] <- hamby44$grooves[[i]]$groove[2] - hamby44$grooves_quad_pred_pos[[i]][2]
}

#hamby44[1:6,]
```


```{r plot-compare-rollapply-quadratic-pos, echo = F, message = F, warning = F}
hamby44 %>% ggplot() + geom_point(aes(x = abs(rollapply_left_diff), y = abs(quadratic_pos_left_diff)))  + 
  geom_point(aes(x = abs(rollapply_right_diff), y = abs(quadratic_pos_right_diff)), shape = 2) +
  geom_abline(intercept = 0, slope = 1) + 
  labs(x = "Absolute Difference between \n Rollapply Groove and Manual ID Groove", 
       y = "Absolute Difference between \n Quadratic Groove and Manual ID Groove", 
       title = "Non-Positive Residuals Method") + 
  theme_bw() + 
  ylim(0, 1100) + 
  xlim(0, 1100)



#hamby44_quad %>% ggplot() + geom_point(aes(x = abs(rollapply_right_diff), y = abs(quadratic_right_diff))) + theme_bw() + geom_abline(intercept = 0, slope = 1)

#hamby44_quad %>% ggplot() + geom_point(aes(x = abs(rollapply_left_diff), y = abs(quadratic_left_diff))) + theme_bw() + geom_abline(intercept = 0, slope = 1)
```



Additionally, we can plot the difference between the two quadratic methods to see if one is better than the other.  



```{r compare-quad-methods, echo = F, warning = F, message = F}
hamby44 %>% ggplot() + geom_point(aes(x = abs(quadratic_left_diff), y = abs(quadratic_pos_left_diff)))  + 
  geom_point(aes(x = abs(quadratic_right_diff), y = abs(quadratic_pos_right_diff)), shape = 2) +
  geom_abline(intercept = 0, slope = 1) + 
  labs(x = "Absolute Difference between \n Quadratic (original) Groove and Manual ID Groove", 
       y = "Absolute Difference between \n Quadratic (positive) Groove and Manual ID Groove") + 
  theme_bw() + 
  ylim(0, 1100) + 
  xlim(0, 1100)
```



```{r, echo = F, warning = F, message = F}
#ggplot() + geom_point(data = hamby44_quad2[1,]$ccdata_avg[[1]], aes(x = y, y = value_std)) + 
#  geom_vline(xintercept = hamby44_quad2[1,]$grooves[[1]]$groove[1], colour = "blue") + 
#  geom_vline(xintercept = hamby44_quad2[1,]$grooves[[1]]$groove[2], colour = "blue") + 
#  geom_vline(xintercept = hamby44_quad2[1,]$grooves_quad_pred[[1]][1], colour = "red") + 
#  geom_vline(xintercept = hamby44_quad2[1,]$grooves_quad_pred[[1]][2], colour = "red")
```



Now, we will look at the sums of residuals between the manually ID'd grooves and the grooves ID'd by the quadratic method.  

We can explore these differences before we actually fit the linear model including this to see if we can see a pattern. We will do this first for the original 4 times median method.  




```{r sum-resid-quadratic, echo = F, warning = F, message = F}
sum_resid_right <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_quad_pred[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

#sum_resid_right <- function(datafile){
#  data <- datafile$ccdata_w_resid[[1]]
#  man_groove <- datafile$grooves[[1]]$groove[1]
#  pred_groove <- datafile$grooves_quad_pred[[1]][1]
#  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
#  return(sum(data$resid, na.rm = T))
#}

## look into pmap - maybe the data we want to be inputted into map is a list of lists (a list of the particular columns we actually want)
#test <- hamby44_quad2[1:3,]
#test %>% mutate(rdiff_resid_sum = purrr::pmap_dbl(, .f = sum_resid_right))

#apply(X = test, MARGIN = 1, FUN = function(x){sum_resid_right(datafile = x)})


# for now, we are just going to do a quick and dirty loop. 

hamby44$rdiff_resid_sum <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum[i] <- sum_resid_right(datafile = hamby44, which_bullet = i)
}


sum_resid_left <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_quad_pred[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$ldiff_resid_sum <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum[i] <- sum_resid_left(datafile = hamby44, which_bullet = i)
}

#hamby44[1:6,]
```


```{r sum-resid-quadratic-plot, echo = F, warning = F, message = F}

hamby44 %>% ggplot() + geom_vline(xintercept = 0, colour = "red") + 
  geom_hline(yintercept = 0, colour = "red") +  
  geom_point(aes(x = -quadratic_right_diff, y = rdiff_resid_sum), shape = 2) + 
  theme_bw() + 
  labs(x = "Difference in Manually ID'd groove and Predicted Groove", 
       y = "Sum of residuals between grooves",
       title = "4*Median Method") + 
  geom_point(aes(x = quadratic_left_diff, y = ldiff_resid_sum)) 
```

The way this plot is set up, we have that the more positive the difference, the further in the manually ID'd groove is towards the center. This means that we are more concerned with positive values along the x-axis (i.e., manual identification puts it further in) than negative values (i.e., we may be losing a little more data than we need, but there aren't grooves inside of where the prediction falls).  



Let's also take a look at this for the new positive residuals cutoff.  

```{r sum-resid-quadratic-pos, echo = F, warning = F, message = F}
sum_resid_right_pos <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_quad_pred_pos[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}



# for now, we are just going to do a quick and dirty loop. 

hamby44$rdiff_resid_sum_pos <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_pos[i] <- sum_resid_right_pos(datafile = hamby44, which_bullet = i)
}


sum_resid_left_pos <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_quad_pred_pos[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$ldiff_resid_sum_pos <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_pos[i] <- sum_resid_left_pos(datafile = hamby44, which_bullet = i)
}

#hamby44[1:6,]
```

```{r sum-resid-quadratic-pos-plot, echo = F, warning = F, message = F}

hamby44 %>% ggplot() + geom_vline(xintercept = 0, colour = "red") + 
  geom_hline(yintercept = 0, colour = "red") +  
  geom_point(aes(x = -quadratic_pos_right_diff, y = rdiff_resid_sum_pos), shape = 2) + 
  theme_bw() + 
  labs(x = "Difference in Manually ID'd groove and Predicted Groove)", 
       y = "Sum of residuals between grooves",
       title = "Positive Residuals Cutoff Method") + 
  geom_point(aes(x = quadratic_pos_left_diff, y = ldiff_resid_sum_pos)) 
```


Let us also look at the sum of the residuals for rollapply, so we can get a sense for whether we are outperforming that method with what we have so far!  

```{r sum-resid-rollapply, echo = F, warning = F, message = F}
sum_resid_right_roll <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_pred[[which_bullet]]$groove[2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$rdiff_resid_roll <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_roll[i] <- sum_resid_right_roll(datafile = hamby44, which_bullet = i)
}


sum_resid_left_roll <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_pred[[which_bullet]]$groove[1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$ldiff_resid_sum_roll <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_roll[i] <- sum_resid_left_roll(datafile = hamby44, which_bullet = i)
}

#hamby44[1:6,]
```

The following are several plots to help illustrate the process and how it is working:  

```{r residuals-dframe-and-plot, echo = F, warning = F, message = F}
#resids_dframe <- data.frame(roll_right = hamby44$rdiff_resid_roll, roll_left = hamby44$ldiff_resid_sum_roll, 
#                             quad_right = hamby44$rdiff_resid_sum, quad_left = hamby44$ldiff_resid_sum, 
#                             pos_right = hamby44$rdiff_resid_sum_pos, pos_left = hamby44$ldiff_resid_sum_pos)


resids_dframe <- data.frame(roll_right = abs(hamby44$rdiff_resid_roll), roll_left = abs(hamby44$ldiff_resid_sum_roll), 
                             quad_right = abs(hamby44$rdiff_resid_sum), quad_left = abs(hamby44$ldiff_resid_sum), 
                             pos_right = abs(hamby44$rdiff_resid_sum_pos), pos_left = abs(hamby44$ldiff_resid_sum_pos))

apply(resids_dframe, MARGIN = 2, mean)
apply(resids_dframe, MARGIN = 2, median)

head(resids_dframe)

#resids_dframe$method <- factor(resids_dframe$method, levels = rev(levels(resids_dframe$method)))
resids_dframe <- resids_dframe  %>% select(-quad_right, -quad_left) %>% gather(method, residuals_sum)

resids_dframe$method <- factor(resids_dframe$method,
    levels = c('roll_left', 'pos_left', 'roll_right', 'pos_right'),ordered = TRUE)

resids_dframe %>% ggplot() + geom_boxplot(aes(x = method, y = residuals_sum)) + 
  theme_bw() + labs(x = "Method and Groove", y = "Residuals") + scale_x_discrete(labels = c("Rollapply, Left", "RLM, Left", "Rollapply, Right", "RLM, Right"))

#resids_dframe  %>% select(-quad_right, -quad_left) %>% gather(method, residuals_sum) %>% filter(residuals_sum < 2000) %>% 
#  ggplot() + geom_boxplot(aes(x = factor(method), y = residuals_sum)) + theme_bw()

resids_dframe <- resids_dframe %>% mutate(method = as.character(method), Method = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][1]
})), GrooveSide = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][2]
})))


resids_dframe %>% mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(2,1)], labels = c("Rollapply", "Robust Linear Model"))) %>% ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + theme_bw() + labs(y = "Sum of Residuals")


resids_dframe %>% 
  mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(2,1)], labels = c("Rollapply", "Robust Linear Model"))) %>%
  filter(residuals_sum < 1000) %>% 
  ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + 
  theme_bw() + labs(y = "Sum of Residuals")


```


## Plots for presentations to explain methods of assessment.  



```{r misidentification-plot-for-slides, echo = F, warning = F, message = F}

#Land 1 is a good example on both sides
#Land 2 is a good example on the right side!
#Land 6 is a good example on the right side

land6_plot <- ggplot() + geom_point(data = hamby44$ccdata_avg[[6]], aes(x = y, y = value_std)) + 
  geom_vline(xintercept = hamby44$grooves[[6]]$groove[1], colour = "blue") + 
  geom_vline(xintercept = hamby44$grooves[[6]]$groove[2], colour = "blue") + 
  geom_vline(xintercept = hamby44$grooves_pred[[6]]$groove[1], colour = "red") + 
  geom_vline(xintercept = hamby44$grooves_pred[[6]]$groove[2], colour = "red") + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[6]][1], colour = "green") + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[6]][2], colour = "green") + 
  theme_bw() + labs(x = "Y Values", y = "Height", title = "Misidentification on Right Side")

land1_plot <- ggplot() + geom_point(data = hamby44$ccdata_avg[[1]], aes(x = y, y = value_std)) + 
  geom_vline(xintercept = hamby44$grooves[[1]]$groove[1], colour = "blue") + 
  geom_vline(xintercept = hamby44$grooves[[1]]$groove[2], colour = "blue") + 
  geom_vline(xintercept = hamby44$grooves_pred[[1]]$groove[1], colour = "red") + 
  geom_vline(xintercept = hamby44$grooves_pred[[1]]$groove[2], colour = "red") + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[6]][1], colour = "green") + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[6]][2], colour = "green") + 
  theme_bw() + labs(x = "Y Values", y = "Height", title = "Misidentification on Both Sides")

library(gridExtra)
grid.arrange(land1_plot, land6_plot, ncol = 1)

```




```{r highlight-plot-for-slides, echo = F, warning = F, message = F}

# 50 is a good example of where manual is just further out because there's no groove
ggplot() + geom_point(data = hamby44$ccdata_w_resid[[20]], aes(x = y, y = resid)) + 
  geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[20]][1], colour = "blue") + 
  geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[20]][2], colour = "blue") + 
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = hamby44$grooves[[20]]$groove[1], colour = "green")  + 
  geom_vline(xintercept = hamby44$grooves[[20]]$groove[2], colour = "green") + 
  labs(x = "Y Values", y = "Residual Values", title = "Assessing Fit - Sum Highlighted Residuals") +
  geom_rect(aes(ymin = min(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T), 
                ymax = max(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T),
                xmax = hamby44$grooves[[20]]$groove[1], 
                xmin = hamby44$grooves_quad_pred_pos[[20]][1]), fill = "yellow", alpha = 0.3) +
  geom_rect(aes(ymin = min(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T), 
                ymax = max(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T),
                xmin = hamby44$grooves[[20]]$groove[2], 
                xmax = hamby44$grooves_quad_pred_pos[[20]][2]), fill = "yellow", alpha = 0.3) +
  theme_bw()
```



```{r more-plots-for-slides, echo = F, warning = F, message = F}
bullet <- hamby44$ccdata[[1]]
lm0 <- MASS::rlm(value~poly(y,2), data=bullet, maxit=100)
bullet$pred <- predict(lm0, newdata=bullet)

  #bullet$absresid <- with(bullet, abs(value-pred))
bullet$resid <- with(bullet, value-pred)
  #bullet$absresid_div <- with(bullet, absresid/value)
  bullet$resid_div <- with(bullet, resid/value)
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid)) + theme_bw()
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid_div)) + theme_bw()
  
  bullet$resid_cutoff <- with (bullet, resid_div > 0)
  groove <- range(filter(bullet, !resid_cutoff)$y) #+ c(adjust, -adjust)
  
  #plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
  #  geom_vline(xintercept=groove[1], colour = "blue") +
  #  geom_vline(xintercept=groove[2], colour = "blue") 

lm1 <- loess(value~y, data = bullet)
bullet$pred2 <- predict(lm1, newdata = bullet)
bullet$resid2 <- with(bullet, value - pred2)

lm2 <- lm(value~poly(y,2), data = bullet)
bullet$pred3 <- predict(lm2, newdata = bullet)
bullet$resid3 <- with(bullet, value - pred3)
  
bplot1 <- bullet %>% ggplot() + geom_point(aes(x = y, y = value)) + geom_line(aes(x = y, y = pred2), color = "red") + 
  theme_bw() + labs(x = "Y Values", y = "Height", title = "LOESS Fit")
bplot2 <- bullet %>% ggplot() + geom_point(aes(x = y, y = resid2)) + 
  theme_bw() + labs(x = "Y Values", y = "Residuals", title = "Residuals from LOESS Fit") +
  geom_hline(yintercept = 0, color = "red")
bplot3 <- bullet %>% ggplot() + geom_point(aes(x = y, y = value)) + geom_line(aes(x = y, y = pred3), color = "red") + 
  theme_bw() + labs(x = "Y Values", y = "Height", title = "Linear Model Fit")
bplot4 <- bullet %>% ggplot() + geom_point(aes(x = y, y = resid3)) + 
  theme_bw() + labs(x = "Y Values", y = "Residuals", title = "Residuals from Linear Model Fit") +
  geom_hline(yintercept = 0, color = "red")
bplot5 <- bullet %>% ggplot() + geom_point(aes(x = y, y = value)) + geom_line(aes(x = y, y = pred), color = "red") + 
  theme_bw() + labs(x = "Y Values", y = "Height", title = "Robust Linear Model Fit")
bplot6 <- bullet %>% ggplot() + geom_point(aes(x = y, y = resid)) +
  theme_bw() + labs(x = "Y Values", y = "Residuals", title = "Residuals from Robust Linear Model Fit") + 
  geom_hline(yintercept = 0, color = "red")


library(gridExtra)
grid.arrange(bplot1, bplot2, bplot3, bplot4, bplot5, bplot6, nrow = 3)



bplot7 <- bullet %>% filter(between(y, groove[1], groove[2])) %>% ggplot() + geom_point(aes(x = y, y = value)) +
  geom_line(aes(x = y, y = pred), color = "red", lwd = 1.2) + 
  theme_bw() + labs(x = "Y Values", y = "Height", title = "Fit to Land Shape")

bplot8 <- bullet %>% filter(between(y, groove[1], groove[2])) %>% ggplot() + geom_line(aes(x = y, y = resid)) + 
  theme_bw() + labs(x = "Y Values", y = "Residuals", title = "Land Signature") + geom_hline(yintercept = 0, color = "red", lwd = 1.2)

grid.arrange(bplot7, bplot8, ncol = 2)
```



## Residuals of quadratic robust linear model - looking for other cutoff values by looking at these residuals.  

Next, we want to try looking at another method that uses the RLM base! That is, we fit the RLM and try looking at different aspects of it (mainly residuals) to determine where the cutoff should be.  



```{r calculate-depth-y-vals, echo = F, warning = F, message = F}

#amby44$ccdata_w_resid[[1]] %>% mutate(depth = y - median(y)) %>% head()
hamby44 <- hamby44 %>% mutate(ccdata_w_resid = purrr::map(ccdata_w_resid, .f = function(x){
  x <- x %>% mutate(depth = y - median(y))
}))

hamby44$ccdata_w_resid[[6]] %>% head()

hamby44 %>% head()
```


## Median Absolute Deviation Stuff  

```{r define_get-grooves-mad, echo = F, message = F, warning = F}
get_grooves_mad <- function(bullet, adjust, multiplier){
  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
  bullet$pred <- predict(lm0, newdata=bullet)

  bullet$absresid <- with(bullet, abs(value-pred))
  #bullet$resid <- with(bullet, value_std-pred)
  bullet$absresid_div <- with(bullet, absresid/value)
  #bullet$resid_div <- with(bullet, resid/value_std)
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid)) + theme_bw()
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid_div)) + theme_bw()
  mad1 <- mad(bullet$absresid, na.rm = T)
  bullet$resid_cutoff <- with(bullet, absresid > mad1*multiplier)
  groove <- range(filter(bullet, !resid_cutoff)$y) + c(adjust, -adjust)
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  
  return(list(groove = groove, plot = plot))
}

```

```{r calculate_get-grooves-mad1, echo = F, message = F, warning = F}
hamby44 <- hamby44 %>% mutate(grooves_mad1 = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_mad(bullet = x, adjust = 0, multiplier = 1)$groove
}))
```



```{r sum_resid_mad1, echo = F, message = F, warning = F}
sum_resid_right_m1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_mad1[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}


# for now, we are just going to do a quick and dirty loop. 


hamby44$rdiff_resid_sum_m1 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_m1[i] <- sum_resid_right_m1(datafile = hamby44, which_bullet = i)
}


sum_resid_left_m1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_mad1[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$ldiff_resid_sum_m1 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_m1[i] <- sum_resid_left_m1(datafile = hamby44, which_bullet = i)
}

#hamby44[1:6,]
```



```{r}
resids_dframe <- data.frame(roll_right = abs(hamby44$rdiff_resid_roll), roll_left = abs(hamby44$ldiff_resid_sum_roll), 
                             quad_right = abs(hamby44$rdiff_resid_sum), quad_left = abs(hamby44$ldiff_resid_sum), 
                             pos_right = abs(hamby44$rdiff_resid_sum_pos), pos_left = abs(hamby44$ldiff_resid_sum_pos),
                             mad1_right = abs(hamby44$rdiff_resid_sum_m1), mad1_left = abs(hamby44$ldiff_resid_sum_m1))

apply(resids_dframe, MARGIN = 2, mean)
apply(resids_dframe, MARGIN = 2, median)

head(resids_dframe)

#resids_dframe$method <- factor(resids_dframe$method, levels = rev(levels(resids_dframe$method)))
resids_dframe <- resids_dframe %>% gather(method, residuals_sum)

resids_dframe$method <- factor(resids_dframe$method,
    levels = c('roll_left', 'quad_left', 'pos_left', 'mad1_left', 'roll_right', 'quad_right', 'pos_right', 'mad1_right'),ordered = TRUE)

#resids_dframe %>% ggplot() + geom_boxplot(aes(x = method, y = residuals_sum)) + 
#  theme_bw() + labs(x = "Method and Groove", y = "Residuals") + scale_x_discrete(labels = c("Rollapply, Left", "RLM, Left", "Rollapply, Right", "RLM, Right"))

#resids_dframe  %>% select(-quad_right, -quad_left) %>% gather(method, residuals_sum) %>% filter(residuals_sum < 2000) %>% 
#  ggplot() + geom_boxplot(aes(x = factor(method), y = residuals_sum)) + theme_bw()

resids_dframe <- resids_dframe %>% mutate(method = as.character(method), Method = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][1]
})), GrooveSide = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][2]
})))


resids_dframe %>% mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(4,3,2,1)], labels = c("Rollapply", "Quadratic", "Robust Linear Model", "Median Absolute Deviation"))) %>% ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + theme_bw() + labs(y = "Sum of Residuals")


resids_dframe %>% 
  mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(4,3,2,1)], 
                         labels = c("Rollapply", "Quadratic", "Robust Linear Model", "Median Absolute Deviation")))  %>%
  filter(residuals_sum < 1000) %>% 
  ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + 
  theme_bw() + labs(y = "Sum of Residuals")
```



```{r calculate_get-grooves-mad2, echo = F, message = F, warning = F}
hamby44 <- hamby44 %>% mutate(grooves_mad2 = purrr::map(ccdata_avg, .f = function(x){
  get_grooves_mad(bullet = x, adjust = 0, multiplier = 2)$groove
}))
```



```{r sum_resid_mad1, echo = F, message = F, warning = F}
sum_resid_right_m2 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_mad2[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}


# for now, we are just going to do a quick and dirty loop. 


hamby44$rdiff_resid_sum_m2 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_m2[i] <- sum_resid_right_m2(datafile = hamby44, which_bullet = i)
}


sum_resid_left_m2 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_mad2[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$ldiff_resid_sum_m2 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_m2[i] <- sum_resid_left_m2(datafile = hamby44, which_bullet = i)
}

#hamby44[1:6,]
```



```{r boxplots-mad1-mad2, echo = F, warning = F, message = F }
resids_dframe <- data.frame(roll_right = abs(hamby44$rdiff_resid_roll), roll_left = abs(hamby44$ldiff_resid_sum_roll), 
                             quad_right = abs(hamby44$rdiff_resid_sum), quad_left = abs(hamby44$ldiff_resid_sum), 
                             pos_right = abs(hamby44$rdiff_resid_sum_pos), pos_left = abs(hamby44$ldiff_resid_sum_pos),
                             mad1_right = abs(hamby44$rdiff_resid_sum_m1), mad1_left = abs(hamby44$ldiff_resid_sum_m1),
                             mad2_right = abs(hamby44$rdiff_resid_sum_m2), mad2_left = abs(hamby44$ldiff_resid_sum_m2))

apply(resids_dframe, MARGIN = 2, mean)
apply(resids_dframe, MARGIN = 2, median)

head(resids_dframe)

#resids_dframe$method <- factor(resids_dframe$method, levels = rev(levels(resids_dframe$method)))
resids_dframe <- resids_dframe %>% gather(method, residuals_sum)

resids_dframe$method <- factor(resids_dframe$method,
    levels = c('roll_left', 'quad_left', 'pos_left', 'mad1_left', 'mad2_left', 'roll_right', 'quad_right', 'pos_right', 'mad1_right', 'mad2_right'),ordered = TRUE)

#resids_dframe %>% ggplot() + geom_boxplot(aes(x = method, y = residuals_sum)) + 
#  theme_bw() + labs(x = "Method and Groove", y = "Residuals") + scale_x_discrete(labels = c("Rollapply, Left", "RLM, Left", "Rollapply, Right", "RLM, Right"))

#resids_dframe  %>% select(-quad_right, -quad_left) %>% gather(method, residuals_sum) %>% filter(residuals_sum < 2000) %>% 
#  ggplot() + geom_boxplot(aes(x = factor(method), y = residuals_sum)) + theme_bw()

resids_dframe <- resids_dframe %>% mutate(method = as.character(method), Method = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][1]
})), GrooveSide = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][2]
})))


resids_dframe %>% mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(5,4,3,1,2)], labels = c("Rollapply", "Quadratic", "Robust Linear Model", "Median Absolute Deviation", "Median Absolute Deviation 2"))) %>% ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + theme_bw() + labs(y = "Sum of Residuals")


resids_dframe %>% 
  mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(5,4,3,1,2)], 
                         labels = c("Rollapply", "Quadratic", "Robust Linear Model", "Median Absolute Deviation", "Median Absolute Deviation 2")))  %>%
  filter(residuals_sum < 1000) %>% 
  ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + 
  theme_bw() + labs(y = "Sum of Residuals")
```







## Predicting which sides have grooves  

We want to next try a two-step process: First, predicting which sides have grooves; then, based on whether the side has a groove or not, iteratively trimming down the data on that side until we get values that are very similar to the rollapply values.  


I am first going to explore what y values the groove locations usually take on.  

```{r explore-groove-locations, echo = F, warning = F, message = F}

hamby44$left_groove <- 0
hamby44$right_groove <- 0
for(i in 1:nrow(hamby44)){
  hamby44$left_groove[i] <- hamby44$grooves[[i]]$groove[1]
  hamby44$right_groove[i] <- hamby44$grooves[[i]]$groove[2]
}

summary(hamby44$left_groove) # Left grooves, from 15.48 to 543.74
summary(hamby44$right_groove) # Right grooves, from 1872 to 2351

hamby44 %>% ggplot() + geom_histogram(aes(x = left_groove), fill = "salmon")  + 
  geom_histogram(aes(x = right_groove), fill = "turquoise") + 
  labs(x = "Groove Locations") + theme_bw()
```

Now, let's take a look at summing up residuals from 0 to the highest left groove location, and from the lowest right groove location up to the max y value.  

```{r, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(left_resid_sum = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y < 600) 
  sum(bullet$resid, na.rm = T)
}), 
right_resid_sum = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y > 1800)
  sum(bullet$resid, na.rm = T)
}))

hamby44 %>% ggplot() + geom_histogram(aes(x = left_resid_sum), fill = "salmon", alpha = 0.3) + geom_histogram(aes(x = right_resid_sum), fill = "turquoise", alpha = 0.3) + theme_bw() 

## Based on the plot, let's go with a cutoff of residual higher than 1000 means there is a groove there for the right side... but I have no idea for the right side!! Let's see if we can get some sort of ground truth...  



```



```{r define-is-groove, echo = F, warning = F, message = F}

hamby44$is_left_groove <- c(1, 1, 1, 1, 1, #5
                            1, 1, 1, 1, 0, #10
                            1, 1, 1, 1, 1, #15
                            1, 1, 1, 1, 1, #20
                            1, 1, 1, 1, 1, #25
                            1, 1, 1, 1, 1, #30
                            1, 0, 1, 1, 1, #35
                            1, 1, 1, 1, 1, #40
                            1, 1, 1, 1, 1, #45
                            1, 1, 1, 1, 1, #50
                            1, 1, 1, 1, 1, #55
                            1, 1, 0, 1, 1, #60
                            1, 1, 1, 1, 1, #65
                            1, 1, 1, 1, 1, #70
                            1, 1, 1, 1, 1, #75
                            1, 1, 1, 1, 1, #80
                            1, 1, 1, 1, 1, #85
                            1, 1, 1, 1, 1, #90
                            1, 1, 1, 1, 1, #95
                            1, 1, 1, 0, 1, #100
                            1, 1, 1, 1, 1, #105
                            1, 1, 1, 1, 1, #110
                            1, 1, 1, 1, 1, #115
                            1, 1, 1, 1, 1, #120
                            1, 1, 1, 1, 1, #125
                            1, 1, 1, 1, 1, #130
                            1, 1, 1, 1, 1, #135
                            1, 1, 1, 1, 1, #140
                            1, 1, 1, 1, 1, #145
                            1, 1, 1, 1, 1, #150
                            1, 1, 1, 1, 1, #155
                            1, 1, 1, 1, 1, #160
                            1, 1, 1, 1, 1, #165
                            1, 1, 1, 1, 1, #170
                            1, 1, 1, 1, 1, #175
                            1, 1, 1, 1, 1, #180
                            1, 1, 1, 1, 1, #185
                            1, 1, 1, 1, 1, #190
                            1, 1, 1, 1, 1, #195
                            1, 1, 1, 1, 1, #200
                            1, 1, 1, 1, 1, #205
                            1, 1, 1)

hamby44$is_right_groove <- c(1, 1, 0, 0, 0, #5 
                             1, 0, 0, 0, 1, #10
                             0, 0, 1, 1, 0, #15
                             0, 1, 1, 1, 0, #20
                             0, 0, 0, 1, 0, #25
                             1, 0, 0, 0, 0, #30
                             1, 1, 1, 0, 1, #35
                             0, 1, 1, 1, 0, #40
                             0, 0, 0, 1, 0, #45
                             1, 0, 1, 0, 0, #50
                             1, 0, 0, 1, 0, #55
                             0, 0, 1, 1, 0, #60
                             0, 1, 0, 0, 1, #65
                             1, 0, 1, 1, 1, #70
                             0, 0, 1, 0, 1, #75
                             0, 1, 0, 1, 0, #80
                             0, 1, 0, 1, 1, #85
                             1, 0, 1, 0, 1, #90
                             0, 0, 0, 1, 1, #95
                             1, 0, 1, 1, 1, #100
                             0, 0, 1, 1, 0, #105
                             0, 0, 1, 0, 0, #110
                             0, 1, 1, 1, 0, #115
                             0, 1, 0, 1, 0, #120
                             1, 1, 1, 0, 0, #125
                             0, 1, 1, 1, 1, #130
                             1, 1, 0, 1, 1, #135
                             1, 1, 0, 0, 0, #140
                             0, 0, 0, 0, 0, #145
                             0, 1, 1, 0, 0, #150
                             1, 1, 0, 1, 0, #155
                             0, 1, 0, 0, 0, #160
                             0, 0, 0, 0, 1, #165
                             1, 0, 1, 0, 0, #170
                             1, 1, 0, 0, 0, #175
                             0, 0, 1, 0, 1, #180
                             0, 1, 0, 1, 0, #185
                             1, 1, 1, 1, 0, #190
                             1, 1, 1, 0, 1, #195
                             1, 1, 1, 0, 1, #200
                             0, 1, 0, 1, 0, #205
                             1, 0, 1)


```

```{r, echo = F, warning = F, message = F}

hamby44 %>% filter(!is.na(is_left_groove)) %>% ggplot() + geom_histogram(aes(x = left_resid_sum, fill = factor(is_left_groove))) + theme_bw()

hamby44 %>% filter(!is.na(is_right_groove)) %>% ggplot() + geom_histogram(aes(x = right_resid_sum, fill = factor(is_right_groove)), binwidth = 200) + theme_bw()


hamby44 %>% ggplot() + geom_point(aes(x = left_resid_sum, y = left_groove, colour = factor(is_left_groove))) + theme_bw()

hamby44 %>% ggplot() + geom_point(aes(x = right_resid_sum, y = right_groove, colour = factor(is_right_groove))) + theme_bw()
```


Now, let's also try calculating the proportion of NA values in the "tails" of the bullet lands, (the same regions we calcuated the sums of residuals on), and whether there are strings of NA values.  

```{r, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(left_na_prop = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y < 600)
  sum(is.na(bullet$value))/nrow(bullet)
}), 
right_na_prop = purrr::map_dbl(ccdata_w_resid, .f = function(bullet){
  bullet <- bullet %>% filter(y > 1800)
  sum(is.na(bullet$value))/nrow(bullet)
})) 

hamby44 %>% ggplot() + geom_point(aes(x = left_na_prop, y = left_groove, colour = factor(is_left_groove))) + theme_bw()

hamby44 %>% ggplot() + geom_point(aes(x = right_na_prop, y = right_groove, colour = factor(is_right_groove))) + theme_bw()
## y < 600 for left side, y > 1800 for right side
```


### Some description plots for predicting each side method!  

```{r}

hamby44 %>% ggplot() + geom_histogram(aes(x = left_groove), fill = "salmon")  + 
  geom_histogram(aes(x = right_groove), fill = "turquoise") + 
  labs(x = "Groove Locations") + theme_bw()


ggplot() + geom_point(data = hamby44$ccdata_w_resid[[20]], aes(x = y, y = value)) + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[20]][1], colour = "blue") + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[20]][2], colour = "blue") + 
  #geom_hline(yintercept = 0) +
  #geom_vline(xintercept = hamby44$grooves[[20]]$groove[1], colour = "green")  + 
  #geom_vline(xintercept = hamby44$grooves[[20]]$groove[2], colour = "green") + 
  labs(x = "Y Values", y = "Height Values", title = "Predicting Groove Presence - Profile") +
  geom_rect(aes(ymin = min(hamby44$ccdata_w_resid[[20]]$pred, na.rm = T), 
                ymax = max(hamby44$ccdata_w_resid[[20]]$pred, na.rm = T),
                xmax = 600, 
                xmin = min(hamby44$ccdata_w_resid[[20]]$y)), fill = "yellow", alpha = 0.3) +
  geom_rect(aes(ymin = min(hamby44$ccdata_w_resid[[20]]$pred, na.rm = T), 
                ymax = max(hamby44$ccdata_w_resid[[20]]$pred, na.rm = T),
                xmin = 1800, 
                xmax = max(hamby44$ccdata_w_resid[[20]]$y)), fill = "yellow", alpha = 0.3) +
  geom_line(data = hamby44$ccdata_w_resid[[20]], aes(x = y, y = pred), colour = "red") + 
  theme_bw()



ggplot() + geom_point(data = hamby44$ccdata_w_resid[[20]], aes(x = y, y = resid)) + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[20]][1], colour = "blue") + 
  #geom_vline(xintercept = hamby44$grooves_quad_pred_pos[[20]][2], colour = "blue") + 
  geom_hline(yintercept = 0, colour = "red") +
  #geom_vline(xintercept = hamby44$grooves[[20]]$groove[1], colour = "green")  + 
  #geom_vline(xintercept = hamby44$grooves[[20]]$groove[2], colour = "green") + 
  labs(x = "Y Values", y = "Height Values", title = "Predicting Groove Presence - Residuals") +
  geom_rect(aes(ymin = min(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T), 
                ymax = max(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T),
                xmax = 600, 
                xmin = min(hamby44$ccdata_w_resid[[20]]$y)), fill = "yellow", alpha = 0.3) +
  geom_rect(aes(ymin = min(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T), 
                ymax = max(hamby44$ccdata_w_resid[[20]]$resid, na.rm = T),
                xmin = 1800, 
                xmax = max(hamby44$ccdata_w_resid[[20]]$y)), fill = "yellow", alpha = 0.3) +
  #geom_line(data = hamby44$ccdata_w_resid[[20]], aes(x = y, y = pred), colour = "red") + 
  theme_bw()





st1 <- hamby44 %>% filter(!is.na(is_left_groove)) %>% ggplot() + 
  geom_histogram(aes(x = left_resid_sum, fill = factor(is_left_groove))) + 
  labs(x = "Sum of Residuals on Left Side") +
  theme_bw()

st2 <- hamby44 %>% filter(!is.na(is_right_groove)) %>% ggplot() + 
  geom_histogram(aes(x = right_resid_sum, fill = factor(is_right_groove)), binwidth = 200) + 
  labs(x = "Sum of Residuals on Right Side") + 
  theme_bw()


st3 <- hamby44 %>% ggplot() + 
  geom_point(aes(x = left_resid_sum, y = left_groove, colour = factor(is_left_groove))) + 
  labs(x = "Sum of Residuals on Left Side", y = "Location of Left Groove (Manual ID)") +
  theme_bw()

st4 <- hamby44 %>% ggplot() + 
  geom_point(aes(x = right_resid_sum, y = right_groove, colour = factor(is_right_groove))) + 
  labs(x = "Sum of Residuals on Right Side", y = "Location of Right Groove (Manual ID)") + 
  theme_bw()

grid.arrange(st1, st2, st3, st4, nrow = 2)
```




We want to iteratively remove the sides of the land, which will hopefully remove what we see as the grooves.  

So what cutoffs do we use for "yes groove, no groove"?  

Can we try a forest to get more intelligent cutoffs? How many features do we need for that?  

No matter, what, start cutting off a percentage of the values - keep going until "rollapply" and "robust linear model" look pretty similar. But have an upper end cutoff to stop at if we haven't stopped yet...  



```{r define-get_groove_iterate, echo = F, warning = F, message = F}
get_grooves_iterate <- function(bullet, adjust){
  sumleft <- bullet %>% filter(y < 600) ## this sums up residuals on the left 1/4 or so of the land
  sumleft <- sum(sumleft$resid, na.rm = T)
  sumright <- bullet %>% filter(y > 1800) ## this sums up residuals on the right 1/4 or so of the land  
  sumright <- sum(sumright$resid, na.rm = T)
  
  
  ## can't find a working "Trim" function for numerics, so I'm going to use a little workaround I found  
  
  ## i'm also first going to look at 
  sum_resids <- sum(bullet$resid, na.rm = T)
  while(sum_resids > 300 ){
    bullet <- bullet[(round(0.01 * length(bullet$y)) : round(0.99 * length(bullet$y))),]
    lm_new <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
    bullet$pred_new <- predict(lm_new, newdata = bullet)
    bullet$resid_new <- with(bullet, value_std-pred_new)
    groove <- range(bullet$y)
    sum_resids <- sum(bullet$resid_new, na.rm = T)
  }
  
  
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  return(list(groove = groove, plot = plot))
}

#get_grooves_quadratic_pos_resid <- function(bullet, adjust) {
#  lm0 <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
#  bullet$pred <- predict(lm0, newdata=bullet)

  #bullet$absresid <- with(bullet, abs(value-pred))
#  bullet$resid <- with(bullet, value_std-pred)
  #bullet$absresid_div <- with(bullet, absresid/value)
#  bullet$resid_div <- with(bullet, resid/value_std)
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid)) + theme_bw()
  #bullet %>% ggplot() + geom_point(aes(x = y, y = resid_div)) + theme_bw()
  
#  bullet$resid_cutoff <- with (bullet, resid_div > 0)
#  groove <- range(filter(bullet, !resid_cutoff)$y) + c(adjust, -adjust)
  
#  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
#    geom_vline(xintercept=groove[1], colour = "blue") +
#    geom_vline(xintercept=groove[2], colour = "blue") 
  
#  return(list(groove = groove, plot = plot))
#}
```



```{r run-get_grooves_iterate}
hamby44 <- hamby44 %>% mutate(grooves_it1 = purrr::map(ccdata_w_resid, .f = function(x){
  get_grooves_iterate(bullet = x, adjust = 0)$groove
}))

```




```{r sum_resid_it1, echo = F, message = F, warning = F}
sum_resid_right_it1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_it1[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}


# for now, we are just going to do a quick and dirty loop. 


hamby44$rdiff_resid_sum_it1 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_it1[i] <- sum_resid_right_it1(datafile = hamby44, which_bullet = i)
}


sum_resid_left_it1 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_it1[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$ldiff_resid_sum_it1 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_it1[i] <- sum_resid_left_it1(datafile = hamby44, which_bullet = i)
}

#hamby44[1:6,]


```




```{r define-get_grooves_iterate2, echo = F, message = F, warning = F}
get_grooves_iterate2 <- function(bullet, adjust){
  left <- bullet %>% filter(y < 600) ## this sums up residuals on the left 1/4 or so of the land
  sumleft <- sum(left$resid, na.rm = T)
  right <- bullet %>% filter(y > 1800) ## this sums up residuals on the right 1/4 or so of the land  
  sumright <- sum(right$resid, na.rm = T)
  
  
  ## can't find a working "Trim" function for numerics, so I'm going to use a little workaround I found  
  
  ## let's first trim down the left side - we almost always need to trim it down.  
  groove_l <- 0
  while(sumleft > 200){
    bullet <- bullet[(round(0.01 * length(bullet$y))) : (length(bullet$y)),]
    lm_new <- MASS::rlm(value_std~poly(y,2), data=bullet, maxit=100)
    bullet$pred_new <- predict(lm_new, newdata = bullet)
    bullet$resid_new <- with(bullet, value_std-pred_new)
    sumleft <- sum(bullet[(bullet$y < 600),]$resid_new, na.rm = T)
    groove_l <- min(bullet$y)
    #redefine sumleft here
  }
  
  groove_r <- max(bullet$y)
  while(sumright > 100){
    bullet <- bullet[1:(round(0.99*length(bullet$y))),]
    lm_new <- MASS::rlm(value_std~poly(y,2), data = bullet, maxit=100)
    bullet$pred_new <- predict(lm_new, newdata = bullet)
    bullet$resid_new <- with(bullet, value_std-pred_new)
    sumright <- sum(bullet[(bullet$y > 1800),]$resid_new, na.rm = T)
    groove_r <- max(bullet$y)
  }
  
  
  groove <- c(groove_l, groove_r)
  
  
  plot <- bullet %>% ggplot(aes(x = y, y = value_std)) + geom_line(size = .5) + theme_bw() +
    geom_vline(xintercept=groove[1], colour = "blue") +
    geom_vline(xintercept=groove[2], colour = "blue") 
  return(list(groove = groove, plot = plot))
}
```


```{r run-get_grooves_iterate2, echo = F, warning = F, message = F}
hamby44 <- hamby44 %>% mutate(grooves_it2 = purrr::map(ccdata_w_resid, .f = function(x){
  get_grooves_iterate2(bullet = x, adjust = 0)$groove
}))


ggplot() + geom_point(data = hamby44$ccdata_w_resid[[4]], aes(x = y, y = value_std)) + 
  geom_vline(data = hamby44[4,], aes(xintercept=grooves_it2[[1]][1]), colour = "blue") + 
  geom_vline(data = hamby44[4,], aes(xintercept=grooves_it2[[1]][2]), colour = "blue") + 
  theme_bw()

```



```{r sum_resid_it2, echo = F, message = F, warning = F}
sum_resid_right_it2 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[2]
  pred_groove <- datafile$grooves_it2[[which_bullet]][2]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}


# for now, we are just going to do a quick and dirty loop. 


hamby44$rdiff_resid_sum_it2 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$rdiff_resid_sum_it2[i] <- sum_resid_right_it2(datafile = hamby44, which_bullet = i)
}


sum_resid_left_it2 <- function(datafile, which_bullet){
  data <- datafile$ccdata_w_resid[[which_bullet]]
  man_groove <- datafile$grooves[[which_bullet]]$groove[1]
  pred_groove <- datafile$grooves_it2[[which_bullet]][1]
  data <- data %>% filter(between(y, min(man_groove, pred_groove), max(man_groove, pred_groove)))
  return(sum(data$resid, na.rm = T))
}

hamby44$ldiff_resid_sum_it2 <- 0
for (i in 1:nrow(hamby44)){
  hamby44$ldiff_resid_sum_it2[i] <- sum_resid_left_it2(datafile = hamby44, which_bullet = i)
}

#hamby44[1:6,]


```



```{r boxplots-it2, echo = F, warning = F, message = F}
resids_dframe <- data.frame(roll_right = abs(hamby44$rdiff_resid_roll), roll_left = abs(hamby44$ldiff_resid_sum_roll), 
                             quad_right = abs(hamby44$rdiff_resid_sum), quad_left = abs(hamby44$ldiff_resid_sum), 
                             pos_right = abs(hamby44$rdiff_resid_sum_pos), pos_left = abs(hamby44$ldiff_resid_sum_pos),
                             mad1_right = abs(hamby44$rdiff_resid_sum_m1), mad1_left = abs(hamby44$ldiff_resid_sum_m1),
                             mad2_right = abs(hamby44$rdiff_resid_sum_m2), mad2_left = abs(hamby44$ldiff_resid_sum_m2), 
                             it1_right = abs(hamby44$rdiff_resid_sum_it1), it1_left = abs(hamby44$ldiff_resid_sum_it1), 
                             it2_right = abs(hamby44$rdiff_resid_sum_it2), it2_left = abs(hamby44$rdiff_resid_sum_it2))

apply(resids_dframe, MARGIN = 2, mean)
apply(resids_dframe, MARGIN = 2, median)

head(resids_dframe)

#resids_dframe$method <- factor(resids_dframe$method, levels = rev(levels(resids_dframe$method)))
resids_dframe <- resids_dframe %>% gather(method, residuals_sum)

#resids_dframe$method <- factor(resids_dframe$method,
#    levels = c('roll_left', 'quad_left', 'pos_left', 'mad1_left', 'mad2_left', 'roll_right', 'quad_right', 'pos_right', 'mad1_right', 'mad2_right'),ordered = TRUE)

#resids_dframe %>% ggplot() + geom_boxplot(aes(x = method, y = residuals_sum)) + 
#  theme_bw() + labs(x = "Method and Groove", y = "Residuals") + scale_x_discrete(labels = c("Rollapply, Left", "RLM, Left", "Rollapply, Right", "RLM, Right"))

#resids_dframe  %>% select(-quad_right, -quad_left) %>% gather(method, residuals_sum) %>% filter(residuals_sum < 2000) %>% 
#  ggplot() + geom_boxplot(aes(x = factor(method), y = residuals_sum)) + theme_bw()

resids_dframe <- resids_dframe %>% mutate(method = as.character(method), Method = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][1]
})), GrooveSide = unlist(purrr::map(method, .f = function(x){
  strsplit(x, "_")[[1]][2]
})))


resids_dframe %>% mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(7,6,5,3,4,1,2)], labels = c("Rollapply", "Quadratic", "Robust Linear Model", "Median Absolute Deviation", "Median Absolute Deviation 2", "Iterate", "Iterate 2"))) %>% ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + theme_bw() + labs(y = "Sum of Residuals")


resids_dframe %>% 
  mutate(Method = factor(Method, levels = levels(as.factor(Method))[c(7,6,5,3,4,1,2)], 
                         labels = c("Rollapply", "Quadratic", "Robust Linear Model", "Median Absolute Deviation", "Median Absolute Deviation 2", "Iterate", "Iterate 2")))  %>%
  filter(residuals_sum < 1000) %>% 
  ggplot() + geom_boxplot(aes(x = GrooveSide, y = residuals_sum, fill = Method)) + 
  theme_bw() + labs(y = "Sum of Residuals")
```











## Slope of cumulative sum of residuals...?  

```{r calculate-absresid-cumsum-slopes, echo = F, warning = F, message = F}
## Try three different window sizes
## Cumulative sum of the absolute residuals (try for each side separately, starting from the beginning for the left groove, starting from the end for the right groove). 
## Fit linear models to rolling windows and look at how the slope is changing

## Shift plots of linear model slopes back to be relative to where the manually ID'd groove is

hamby44 <- hamby44 %>% mutate(ccdata_w_resid = purrr::map(ccdata_w_resid, .f = function(x){
  x <- x %>% mutate(resid0 = ifelse(is.na(absresid), 0, absresid), resid_div = ifelse((is.na(value_std) | value_std == 0), 0, resid0/value_std), resid_sum = cumsum(resid_div))
}))


hamby44$ccdata_w_resid[[10]] %>% ggplot() + theme_bw() + geom_point(aes(x = y, y = value_std)) + geom_line(aes(x = y, y = pred), colour = "blue")
hamby44$ccdata_w_resid[[10]] %>% ggplot() + theme_bw() + geom_point(aes(x = y, y = absresid))

hamby44$ccdata_w_resid[[10]] %>% ggplot() + theme_bw() + geom_point(aes(x = depth, y = resid_sum, colour = is.na(absresid))) #+ geom_point(aes(x = y_rev, y = resid_sum_right)) # 



hamby44 <- hamby44 %>% mutate(ccdata_w_resid = purrr::map(ccdata_w_resid, .f = function(x){
  x <- x %>% mutate(left_lm_slope = zoo::rollapply(data = zoo(x), width = 50, FUN = function(Z){
    t = lm(resid_sum~depth, data = as.data.frame(Z))
    return(t$coef[2])
  }, by.column = FALSE, align = "center", partial = T))
}))

plot_grooves <- function(num){
  data <- hamby44$ccdata_w_resid[[num]]
  cutoff <- quantile(data$left_lm_slope, .9)
  data %>% ggplot() + theme_bw() + geom_point(aes(x = y, y = left_lm_slope, colour = factor(left_lm_slope>cutoff))) + geom_vline(xintercept = hamby44$grooves[[num]]$groove, colour = "green")}

library(gridExtra)
grid.arrange(plot_grooves(1), plot_grooves(2), plot_grooves(3), plot_grooves(4))
grid.arrange(plot_grooves(5), plot_grooves(6), plot_grooves(7), plot_grooves(8))

plot_grooves(1)
hamby44$ccdata_w_resid[[1]] %>% ggplot() + theme_bw() + geom_histogram(aes(x = left_lm_slope))

```


Now, we want to iteratively fit a loess and compare the predicted value until they "converge". To do this, we will write a function that takes in a gradient of quantile values and a bullet and returns a data frame containing each of the quantile values as well as the absolute value of the difference in fitted values from the loess. These loess models are fit on data between the percentile shown and (1-percentile). These are fit up to 0.25, meaning by the time we get there we are left with only the middle 50% of the original y values.  


```{r, echo = F, warning = F, message = F}

get_difference_curve <- function(bullet, by_interval){
  qs <- seq(0, 0.25, by = by_interval)
  sum_abs_diff <- c()
  for (i in 1:(length(qs)-1)){
  d <- bullet %>% filter(between(y, quantile(bullet$y, qs[i]), quantile(bullet$y, 1-qs[i])))
  d2 <- bullet %>% filter(between(y, quantile(bullet$y, qs[i+1]), quantile(bullet$y, 1 - qs[i+1])))
  fit <- loess(value_std~y, data = d)
  fit2 <- loess(value_std~y, data = d2)
  sum_abs_diff[i] <- sum(abs(fit$fitted - fit2$fitted))
  }
  return(data.frame(Quantile_Vals = qs[1:(length(qs)-1)], Absolute_Diffs = sum_abs_diff))
}


b_row <- 4
bullet <- hamby44$ccdata_w_resid[[b_row]]
tst_loess <- get_difference_curve(bullet = bullet, by_interval = .005)
ecdf_fun <- function(x,perc) ecdf(x)(perc)
left_groove <- ecdf_fun(bullet$y,hamby44$grooves[[b_row]]$groove[1])
ggplot() + geom_line(aes(x = Quantile_Vals, y = Absolute_Diffs), data = tst_loess) + theme_bw() + 
  geom_vline(xintercept = left_groove, colour = "red")


### move in from either side independently - slide off maximum 

### loess, compute absolute residuals, chop off .5% most extreme 

### iteratively fitting the RLM instead might work - removing the largest residuals iteratively until we don't get residuals larger than some value. Or, sum of raw residuals close to 0. 

### Can also keep track of how much the parameters change with the RLM. 

### look at the difference between a RLM fit and a loess fit?

### Another thing to think about - what are the properties of the median? Median absolute deviation from the median (MAD from the median), to figure out what that looks like. Look at what the MAD is for one groove, two grooves, zero grooves. If the MAD is higher for situations for two grooves. Thinking about confidence intervals/confidence levels having to do with the MAD.

### If the MAD doesn't change with different #'s of grooves, that's what we want. We will cut off more for when there are two grooves, less than when there are no grooves.

### What do we lose by chopping off the negative residuals? Take either only positive residuals or absolute residuals.  

### look at MAD for single groove bullet (where right groove = max(y))

### 
```

Next we will consider fitting a linear model to fit the difference between manual and predicted grooves based on the sum of the residuals that occur between them and the depth (how far away they are from the center). We will calculate this "center" based on the median of the y values. *Note: something to consider if we are getting wonky results, are all the y values there even if there isn't a value, or where there is missing data are we also missing the y values? This could throw off the median of y*.  



Now, let's try to fit a linear model! We want to fit a model of how far apart the grooves are by their depth, whether they are a left or right groove, and the sum of the residuals between them.  

The first thing we have to do is create a data frame with all this info! 
```{r create-assess-frame, echo = F, warning = F, message = F}
pred_assess <- data.frame(is_right_groove = rep(c(1,0), each = 208), pred_diff = c(-1*hamby44$quadratic_right_diff, hamby44$quadratic_left_diff), resid_sum = c(hamby44$rdiff_resid_sum, hamby44$ldiff_resid_sum))

pred_assess %>% head()
```

```{r ass-model-1, echo = F, warning = F, message = F}
ass_model1 <- lm(pred_diff ~ is_right_groove + resid_sum, data = pred_assess)
summary(ass_model1)
```






### Notes 

If it doesn't do well, try one of the other methods within rlm ("MM", "model.frame", etc. the default is "M").

Ideas: dividing by absolute height (may have to standardize down to zero), dividing by relative closeness to edge of the overall bullet land,

Fitting several different shapes (polynomial of order 2, polynomial of order 4 - maybe not polynomial of order 3 because whichever shoulder is higher will 'take over'.)  Polynomial order 3 doesn't converge? does converge?

When we do these things, want to check how far away they are from the manually ID'd ones. In some cases, the manual ID is going to be all the way at the edge, not adjusted after automatically put there. 

Looking at the residuals, if we rollapply across and see what the proportion of the sign is (where sign is where the difference between residual i and residual i-1), where does that proportion start evening out? - *No, it does not. Looking at it, it is all over the place (even with a huge window)*

Depth - from the median of the y's all the way to the furthest data point we have. 
If we do a rollapply on the residuals after, make sure that we average across the residuals first, because there are 9 crosscuts involved. 

One option could be to sum the residuals between where the rollapply location is and where the quadratic location is. Maybe use a linear model to model the difference in the two (the y) by the residuals and the depth (depth of 0 is the median of the y's, so )

Trimming and continuing until the rlm parameters stop changing. Splice off 1/2 a percent (highest 1/2 percent of residuals each time) each time and compare what parameters we are getting in the rlm





Trim off most extreme absolute residuals, go until we get to within the values of the grooves

Keep track of which y (x) values we are trimming, so that it is mostly trimming the values on the outside, and not too much in the middle.

Each trim, calculate mean, median, mad, and standard deviation - see how close these values are once we actually get to the identified the grooves values 


Machine learning problem? First try to predict how many grooves there are. Second step, identify for each number of grooves, an optimized number for trimming. If there is a single groove, there might be a little more mass for one side.  

Maximum difference on either side, we can see whether there is a groove or not a groove. If sum of residuals on a given side is above a certain value, we are dealing with a groove. Trim on relevant sides, and then re-fit robust linear model and rollapply, and compare the differences in the predicted values.  

Model the process we are doing when trying to manually do it, we might get close to what we want to do.  



"This is an epsilon we can worry about later."


